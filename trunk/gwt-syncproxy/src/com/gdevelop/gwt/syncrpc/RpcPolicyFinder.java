/*
 * Copyright www.gdevelop.com.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.gdevelop.gwt.syncrpc;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RpcPolicyFinder {
	private static void dumpRemoteService(Map<String, String> result) {
		if (result.size() > 0) {
			logger.fine("Found " + result.size()
					+ " RemoteService(s) in the classpath");
			String s = "";
			for (String className : result.keySet()) {
				s += className + "\n";
			}
			logger.finer(s);
		} else {
			logger.warning("No RemoteService in the result");
		}
	}

	/**
	 *
	 * In the event (such as in 2.7.0) that serializationpolicy's are no longer
	 * stated in the nocache.js file. This method examines the
	 * compilation-mappings.txt file that is generated by GWT
	 *
	 * @param moduleBaseURL
	 * @return
	 * @throws IOException
	 */
	public static Map<String, String> fetcherSerializationPolicyNameJS(
			String moduleBaseURL) throws IOException {
		Map<String, String> result = new HashMap<String, String>();
		// get compilation-mappings.txt
		// match first cache.js
		// match all possible policy file names in the cache.js
		String moduleCompilationMappings = "compilation-mappings.txt";
		String responseText = getResposeText(moduleBaseURL
				+ moduleCompilationMappings);
		// parse the compilation mappings for any browser cache.js
		// Permutation name is 32 chars surrounded by apostrophe
		String regex = "([A-Z0-9]){32}\\.cache\\.js";
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(responseText);
		if (matcher.find()) {
			String browserSpec = matcher.group();
			responseText = getResposeText(moduleBaseURL + browserSpec);
			pattern = Pattern.compile("\'([A-Z0-9]){32}\'");
			matcher = pattern.matcher(responseText);
			int i = 0;
			while (matcher.find()) {
				String policyName = matcher.group();
				policyName = policyName.replace("\'", "");
				if (0 == i++) {
					// The first one is the permutation name
					continue;
				}
				responseText = getResposeText(moduleBaseURL + policyName
						+ GWT_PRC_POLICY_FILE_EXT);
				result.putAll(parsePolicyName(policyName,
						new ByteArrayInputStream(responseText.getBytes("UTF8"))));
			}
		}
		if (result.size() == 0) {
			logger.config("No RemoteService fetched from server using JS fetcher");
		} else {
			logger.info("Remote Services found with JS Fetcher");
			dumpRemoteService(result);
		}

		return result;
	}

	public static Map<String, String> fetchSerializationPolicyName(
			String moduleBaseURL) throws IOException {
		Map<String, String> result = new HashMap<String, String>();

		moduleBaseURL = moduleBaseURL.trim(); // remove outer trim just in case
		String[] urlparts = moduleBaseURL.split("/");
		// get last word of url appended with .nocache.js
		String moduleNoCacheJs = urlparts[urlparts.length - 1] + ".nocache.js";
		logger.config("Fetching Serialization Policys from: " + moduleNoCacheJs);
		String responseText = "";
		responseText = getResposeText(moduleBaseURL + moduleNoCacheJs);
		// parse the .nocache.js for list of Permutation name
		// Permutation name is 32 chars surrounded by apostrophe
		String regex = "\'([A-Z0-9]){32}\'";
		Pattern pattern = Pattern.compile(regex);
		Matcher matcher = pattern.matcher(responseText);

		boolean xsiFrameLinker = responseText.contains(".cache.js");
		logger.config("XSIFrameLinker: " + xsiFrameLinker);
		if (matcher.find()) {
			if (!xsiFrameLinker) {
				logger.config("Searching for policy's generated by standard linker");
				String permutationFile = matcher.group();
				permutationFile = permutationFile.replace("\'", "");

				// Load the first permutation html file
				permutationFile += ".cache.html";
				logger.fine("Accessing permutation file: " + permutationFile);
				responseText = getResposeText(moduleBaseURL + permutationFile);
				matcher = pattern.matcher(responseText);
				int i = 0;
				while (matcher.find()) {
					String policyName = matcher.group();
					policyName = policyName.replace("\'", "");
					if (0 == i++) {
						// The first one is the permutation name
						continue;
					}
					logger.fine("Accessing policy file: " + policyName);
					responseText = getResposeText(moduleBaseURL + policyName
							+ GWT_PRC_POLICY_FILE_EXT);
					result.putAll(parsePolicyName(
							policyName,
							new ByteArrayInputStream(responseText
									.getBytes("UTF8"))));
				}
			} else {
				logger.config("Searching for policy's generated by XSIFrame linker");
				String permutationFile = matcher.group();
				permutationFile = permutationFile.replace("\'", "");

				// Load the first permutation js file
				permutationFile += ".cache.js";
				logger.fine("Accessing permutation file: " + permutationFile);
				responseText = getResposeText(moduleBaseURL + permutationFile);

				String rpcRegex = "\\\"([A-Z0-9]){32}\\\"";
				Pattern rpcPattern = Pattern.compile(rpcRegex);

				matcher = rpcPattern.matcher(responseText);
				while (matcher.find()) {
					String policyName = matcher.group();
					policyName = policyName.replace("\"", "");
					logger.fine("Accessing policy file: " + policyName);
					responseText = getResposeText(moduleBaseURL + policyName
							+ GWT_PRC_POLICY_FILE_EXT);
					result.putAll(parsePolicyName(
							policyName,
							new ByteArrayInputStream(responseText
									.getBytes("UTF8"))));
				}
			}
		}

		if (result.size() == 0) {
			logger.config("No RemoteService fetched from server using JS/HTML fetcher");
			result = fetcherSerializationPolicyNameJS(moduleBaseURL);
		} else {
			logger.info("Found RemoteServices with JS/HTML Fetcher");
			dumpRemoteService(result);
		}
		return result;
	}

	public static String getCachedPolicyFile(String url) {
		return CACHE_POLICY_FILE.get(url);
	}

	private static String getResposeText(String myurl) throws IOException {
		URL url = new URL(myurl);
		HttpURLConnection connection = (HttpURLConnection) url.openConnection();
		connection.setDoInput(true);
		connection.setDoOutput(true);
		connection.setInstanceFollowRedirects(true); // follow redirect
		connection.setRequestMethod("GET");
		connection.connect();

		InputStream is = connection.getInputStream();
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		byte[] buffer = new byte[1024];
		int len;
		while ((len = is.read(buffer)) > 0) {
			baos.write(buffer, 0, len);
		}
		String responseText = baos.toString("UTF8");

		if (myurl.endsWith(GWT_PRC_POLICY_FILE_EXT)) {
			CACHE_POLICY_FILE.put(myurl, responseText);
		}

		return responseText;
	}

	private static Map<String, String> parsePolicyName(String policyName,
			InputStream in) throws IOException {
		Map<String, String> result = new HashMap<String, String>();

		BufferedReader reader = new BufferedReader(new InputStreamReader(in));
		String line = reader.readLine();
		while (line != null) {
			int pos = line.indexOf(", false, false, false, false, _, ");
			if (pos > 0) {
				result.put(line.substring(0, pos), policyName);
				result.put(line.substring(0, pos) + "Async", policyName);
			}
			line = reader.readLine();
		}

		return result;
	}

	public static Map<String, String> searchPolicyFileInClassPath() {
		Map<String, String> result = new HashMap<String, String>();
		String classPath = System.getProperty("java.class.path");
		StringTokenizer st = new StringTokenizer(classPath, File.pathSeparator);
		while (st.hasMoreTokens()) {
			String path = st.nextToken();
			File f = new File(path);
			if (f.isDirectory()) {
				result.putAll(searchPolicyFileInDirectory(path));
			}
			// TODO: Search in jar, zip files
		}

		if (result.size() == 0) {
			logger.info("No RemoteService in the classpath");
		} else {
			dumpRemoteService(result);
		}

		return result;
	}

	public static Map<String, String> searchPolicyFileInDirectory(String path) {
		Map<String, String> result = new HashMap<String, String>();

		String policyName = null;
		File f = new File(path);
		String[] children = f.list(new FilenameFilter() {
			@Override
			public boolean accept(File dir, String name) {
				if (name.endsWith(GWT_PRC_POLICY_FILE_EXT)) {
					return true;
				}
				return false;
			}
		});

		for (String child : children) {
			policyName = child.substring(0, child.length()
					- GWT_PRC_POLICY_FILE_EXT.length());
			try {
				result.putAll(parsePolicyName(policyName, new FileInputStream(
						new File(path, child))));
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}

		return result;
	}

	private static final Map<String, String> CACHE_POLICY_FILE = new HashMap<String, String>();

	private static final String GWT_PRC_POLICY_FILE_EXT = ".gwt.rpc";

	private static final Logger logger = Logger.getLogger(RpcPolicyFinder.class
			.getName());
}